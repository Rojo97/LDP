S -> Tipo id ( Args ) { A }             NPATH = A.NP

Tipo -> TipoSimple
        | TipoComp
        | void

TipoSimple ->   int 
            | boolean
            | byte
            | float
            | char
            | double
            | long
            | short

TipoComp -> signed TipoSimple
         | unsigned TipoSimple

Args -> Arg 
        | Arg Args

A -> Exp A      A.NP = Exp.NP * A"dentro".NP
    | Flujo A   A.NP = Flujo.NP * A"dentro".NP
    | ε         A.NP = 1

Arg -> Tipo id
        | Tipo id ,
        | id ,
        | id
        | ε

Exp -> Asig ;               Exp.NP = Asig.NP
        | Func ;            Exp.NP = Func.NP
        | Return ;          Exp.NP = Return.NP
        | break ;           Exp.NP = 1

Asig -> Tipo id = Func ;        Asig.NP = 1
        | Tipo Ids ;            Asig.NP = 1

Func -> ID ( Args ) ;           Func.NP = 1
        | Op                    Func.NP = 1

Op ->  ( Op )
     | Op + Op
     | Op - Op
     | Op * Op
     | Op / Op
     | Op % Op
     | id
     | num

Flujo -> If                     flujo.NP = If.NP
        | If Else               flujo.NP = If.NP + Else.NP -1
        | While                 flujo.NP = while.NP
        | do { A } while ( C ) ;        flujo.NP =  A.NP + C.NP + 1
        | For                   flujo.NP = For.NP
        | Switch                flujo.NP = switch.NP 

If -> if ( C ) { A }            If.NP = C.NP + A.NP + 1
    | if ( C ) Exp              If.NP = C.NP + Exp.NP + 1

Else -> else { A }              Else.NP = A.NP
        | else Exp              Else.NP = Exp.NP

While -> while ( C ) { A }      While.NP = C.NP + A.NP + 1
        | while ( C ) Exp       While.NP = C.NP + Exp.NP + 1

For -> for ( Asig ; C ; Func ) { A }    For.NP = Asig.NP + C.NP + Func.NP + A.NP + 1
        | for ( Asig ; C ; Func ) Exp   For.NP = Asig.NP + C.NP + Func.NP + Exp.NP + 1

Switch -> switch ( Func ) { Cases default : A }      Switch.NP = Func.NP + cases.NP + A.NP
        | switch ( Func ) { Cases }                  Switch.NP = Func.NP + cases.NP

Return -> | return ( Func )             Return.NP = 1
          | return Id                   Return.NP = 1

C -> ( C )      C.NP = C.NP
    | C Comp C  C.NP = C.NP + Comp.NP + C.NP
    | id        C.NP = 0
    | num       C.NP = 0
    | Boolean   C.NP = 0

Comp -> = =     Comp.NP = 0
        | ! =   Comp.NP = 0
        | >     Comp.NP = 0
        | <     Comp.NP = 0
        | > =   Comp.NP = 0
        | < =   Comp.NP = 0
        | < >   Comp.NP = 0
        | & &   Comp.NP = 1
        | | |   Comp.NP = 1

Boolean -> True
            | False

Ids -> id
    | id , Ids
    | ε 

Cases -> case id: A Cases               Cases.NP = A.NP + Cases.NP
        | case num : A Cases            Cases.NP = A.NP + Cases.NP

