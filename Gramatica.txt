S -> Tipo id ( Args ) { A }             NPATH = A.NP

Tipo -> TipoSimple
        | TipoComp
        | void

TipoSimple ->   int
            | boolean
            | byte
            | float
            | char
            | double
            | long
            | short

TipoComp -> signed TipoSimple
         | unsigned TipoSimple

Args -> Arg
        | Arg Args

A -> Exp A      A.NP = Exp.NP * A"dentro".NP
    | Flujo A   A.NP = Flujo.NP * A"dentro".NP
    | ε         A.NP = 1

Arg -> Tipo id
        | Tipo id ,
        | id ,
        | id
        | ε

Exp -> Asig ;               Exp.NP = Asig.NP
        | Func ;            Exp.NP = Func.NP
        | Return ;          Exp.NP = Return.NP
        | break ;           Exp.NP = 1

Asig -> Tipo id = Func ;        Asig.NP = 1
        | Tipo Ids ;            Asig.NP = 1

Func -> ID ( Args ) ;           Func.NP = 1
        | Op                    Func.NP = 1

Op ->  ( Op ) Op2
     | id Op2
     | num Op2

Op2 -> + Op Op2
      | - Op Op2
      | * Op Op2
      | / Op Op2
      | % Op Op2
      | ε

Flujo -> If                     flujo.NP = If.NP
        | If Else               flujo.NP = If.NP + Else.NP -1
        | While                 flujo.NP = while.NP
        | do { A } while ( C ) ;        flujo.NP =  A.NP + C.NP + 1
        | For                   flujo.NP = For.NP
        | Switch                flujo.NP = switch.NP

If -> if ( C ) { A }            If.NP = C.NP + A.NP + 1
    | if ( C ) Exp              If.NP = C.NP + Exp.NP + 1

Else -> else { A }              Else.NP = A.NP
        | else Exp              Else.NP = Exp.NP

While -> while ( C ) { A }      While.NP = C.NP + A.NP + 1
        | while ( C ) Exp       While.NP = C.NP + Exp.NP + 1

For -> for ( Asig ; C ; Func ) { A }    For.NP = Asig.NP + C.NP + Func.NP + A.NP + 1
        | for ( Asig ; C ; Func ) Exp   For.NP = Asig.NP + C.NP + Func.NP + Exp.NP + 1

Switch -> switch ( Func ) { Cases default : A }      Switch.NP = Func.NP + cases.NP + A.NP
        | switch ( Func ) { Cases }                  Switch.NP = Func.NP + cases.NP

Return -> | return ( Func )             Return.NP = 1
          | return Id                   Return.NP = 1

C -> ( C ) C2      C.NP = C.NP + C2.NP
    | id C2        C.NP = C2.NP
    | num C2       C.NP = C2.NP
    | Boolean C2   C.NP = Boolean.NP + C2.NP

C2 -> Comp C C2       C2.NP = Comp.NP + C.NP +  C2.NP
      | ε             C2.NP = 0


Comp ->   >    Comp.NP = 0
        | <    Comp.NP = 0
        | >=   Comp.NP = 0
        | <=   Comp.NP = 0
        | ==   Comp.NP = 0
        | !=   Comp.NP = 0
        | &&   Comp.NP = 1
        | ||   Comp.NP = 1
        | &    Comp.NP = 1
        | |    Comp.NP = 1

Boolean -> True       Boolean.NP = 0
            | False   Boolean.NP = 0

Ids -> id
    | id , Ids
    | ε

Cases -> case id: A Cases               Cases.NP = A.NP + Cases.NP
        | case num : A Cases            Cases.NP = A.NP + Cases.NP
